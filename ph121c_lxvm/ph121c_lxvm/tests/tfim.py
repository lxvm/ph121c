"""Test interfaces in the tfim subpackage using unittest.
"""

import os
import unittest
from tempfile import mkstemp
from itertools import product, combinations

import numpy as np
import scipy.linalg as la
import scipy.sparse.linalg as sla

from .. import tfim, data, basis


def param_sweep (
    L  = np.arange(4, 11, 2),
    h  = np.array([0.3, 1.0, 1.7]),
    bc = np.array(['o', 'c']),
    **kwargs
):
    """Generate parameter values to sweep over"""
    keys = ['L', 'h', 'bc']
    keys.extend(kwargs.keys())
    for values in product(L, h, bc, *kwargs.values()):
        yield { k : v for k, v in zip(keys, values) }
         
            
class tfim_x_z_test_case (unittest.TestCase):
    """Test that all the Hamiltonians are consistent."""
    def setUp (self):
        self.params = dict(
            L  = np.arange(4, 11, 2),
            h  = np.array([0.3, 1.0, 1.7]),
            bc = np.array(['o', 'c']),
        )
    def check_sparse_dense_oper_consistent (self, module, **kwargs):
        """Check matrix elements match using dense and sparse methods."""
        for params in param_sweep(**kwargs):
            dense  = module.H_dense(**params)
            sparse = module.H_sparse(**params)
            oper   = module.H_oper(**params)
            with self.subTest(
                name=module.__name__ + ':dense_elem==sparse_elem',
                **params
            ):
                # Check elementwise equality
                self.assertTrue(
                    np.allclose(dense, sparse.toarray())
                )
            with self.subTest(
                name=module.__name__ + ':sparse_eval==oper_eval',
                **params
            ):
                # The LinearOperator is implemented using the same function
                # that created the H_dense matrix, but we still apply this test
                # to check the eigenvalues generated by both sparse methods.
                # Plus this test caught several errors in the H_vec function
                self.assertTrue(
                    np.allclose(
                        sla.eigsh(
                            sparse,
                            which='BE',
                            return_eigenvectors=False,
                        ),
                        sla.eigsh(
                            oper,
                            which='BE',
                            return_eigenvectors=False,
                        )
                    )
                )

    def test_z_consistent (self):
        """Check consistency of methods in ph121c_lxvm.tfim.z."""
        self.check_sparse_dense_oper_consistent(
            tfim.z,
            **self.params,
        )
                
    def test_x_consistent (self):
        """Check consistency of methods in ph121c_lxvm.tfim.x."""
        self.check_sparse_dense_oper_consistent(
            tfim.x, 
            **self.params,
            **dict(sector=['+', '-', 'f']),
        )
        
    def test_z_x_interconsistent (self):
        """Check that the matrices produced by x and z are a change of basis."""
        for params in param_sweep(**self.params):
            with self.subTest(name='compare:z_elem==x_elem', **params):
                # get H_x in the full basis
                xf = tfim.x.H_dense(sector='f', **params)
                # direct sum of sectors to obtain H_x in full basis
                xp = tfim.x.H_dense(sector='+', **params)
                xm = tfim.x.H_dense(sector='-', **params)
                xd = np.zeros(np.add(xp.shape, xm.shape))
                xd[:xp.shape[0], :xp.shape[1]] = xp
                xd[xp.shape[0]:, xp.shape[1]:] = xm
                # permute direct sum to full basis
                iperm = basis.unitary.Ising(params['L'], inverse=True)
                self.assertTrue(
                    np.allclose(xf, xd[iperm, :][:, iperm])
                )
                # perform change from z basis to x basis
                zf = tfim.z.H_dense(**params)
                hd = basis.unitary.Hadamard(params['L'])
                self.assertTrue(
                    np.allclose(xf, hd @ zf @ hd)
                )
                # Test decomposition into sectors
                perm = basis.unitary.Ising(params['L'])
                self.assertTrue(
                    np.allclose((hd @ zf @ hd)[perm, :][:, perm], xd)
                )
    
    
class tfim_data_test_case (unittest.TestCase):
    """Test the data storage and retrieval backend."""
    
    def setUp (self):
        """Set testing parameters"""
        self.oper = tfim.z.H_sparse
        self.oper_params = [
            {
                'L'  : set([4, 5]),
                'h'  : set([0.3, 1.0, 1.7]),
                'bc' : set(['o', 'c']),
            },
            {
                'L'  : set([4, 6]),
                'h'  : set([0.3, 1.0, 1.7]),
                'bc' : set(['o', 'c']),
            },
        ]
        self.solver = sla.eigsh
        self.solver_params = [
            {
                'k' : 6,
                'which' : 'BE',
            }
        ]
        self.archive = mkstemp()[1]
        
    def test_hashable_naming (self):
        """Check naming is unique and repeatable"""
        for solver_params in self.solver_params:
            for oper_params_tuple in zip(
                *[ param_sweep(**p) for p in self.oper_params ]
            ):
                names = [
                    tfim.data.job_name(
                        self.oper,   oper_params,
                        self.solver, solver_params,
                    ) 
                    for oper_params in oper_params_tuple
                ]
                for pair in combinations(
                    zip(names, oper_params_tuple), r=2
                ):
                    if pair[0][1] == pair[1][1]:
                        self.assertTrue(pair[0][0] == pair[1][0])
                    else:
                        self.assertTrue(pair[0][0] != pair[1][0])

    def test_hdf5_interface (self):
        """Make sure reading and writing to archive works."""
        for solver_params in self.solver_params:
            for oper_params in param_sweep(**self.oper_params[0]):
                job = [self.oper, oper_params, self.solver, solver_params]
                with self.subTest(name='calculates new dataset on first time'):
                    _ = tfim.data.obtain(
                        *job, archive=self.archive, batch=True,
                    )
                    self.assertTrue(
                        tfim.data.LAST_EXIT_MODE == tfim.data.EXIT_MODES[1]
                    )
                with self.subTest(name='fetches previously calculated data'):
                    fetch = tfim.data.obtain(
                        *job, archive=self.archive, batch=False,
                    )
                    self.assertTrue(
                        tfim.data.LAST_EXIT_MODE == tfim.data.EXIT_MODES[0]
                    )
                with self.subTest(name='correctly stores/retrieves metadata'):
                    metadata = data.hdf5.inquire(
                        self.archive, path=tfim.data.job_name(*job),
                    )
                    for k, v in tfim.data.job_metadata(*job).items():
                        self.assertTrue(v == metadata[k])

    def tearDown(self):
        """Delete temp file"""
        os.remove(self.archive)

        
if __name__ == '__main__':
    unittest.main()