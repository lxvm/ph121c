"""Test interfaces in the tfim subpackage using unittest.

Modules and procedures tested:
x, y: all backends in fortran
"""

import unittest
from itertools import product

import numpy as np
import scipy.linalg as la
import scipy.sparse.linalg as sla

from .. import tfim, basis


def param_sweep (
    L  = np.arange(4, 11, 2),
    h  = np.array([0.3, 1.0, 1.7]),
    bc = np.array(['o', 'c']),
    **kwargs
):
    """Generate parameter values to sweep over"""
    keys = ['L', 'h', 'bc']
    keys.extend(kwargs.keys())
    for values in product(L, h, bc, *kwargs.values()):
        yield { k : v for k, v in zip(keys, values) }
         
            
class x_z_test_case (unittest.TestCase):
    """Test that all the Hamiltonians are consistent."""
    def setUp (self):
        self.params = dict(
            L  = np.arange(4, 11, 2),
            h  = np.array([0.3, 1.0, 1.7]),
            bc = np.array(['o', 'c']),
        )
    def check_sparse_dense_oper_consistent (self, module, **kwargs):
        """Check matrix elements match using dense and sparse methods."""
        for params in param_sweep(**kwargs):
            dense  = module.H_dense(**params)
            sparse = module.H_sparse(**params)
            oper   = module.H_oper(**params)
            with self.subTest(
                name=module.__name__ + ':dense_elem==sparse_elem',
                **params
            ):
                # Check elementwise equality
                self.assertTrue(
                    np.allclose(dense, sparse.toarray())
                )
            with self.subTest(
                name=module.__name__ + ':sparse_eval==oper_eval',
                **params
            ):
                # The LinearOperator is implemented using the same function
                # that created the H_dense matrix, but we still apply this test
                # to check the eigenvalues generated by both sparse methods.
                # Plus this test caught several errors in the H_vec function
                self.assertTrue(
                    np.allclose(
                        sla.eigsh(
                            sparse,
                            which='BE',
                            return_eigenvectors=False,
                        ),
                        sla.eigsh(
                            oper,
                            which='BE',
                            return_eigenvectors=False,
                        )
                    )
                )

    def test_z_consistent (self):
        """Check consistency of methods in ph121c_lxvm.tfim.z."""
        self.check_sparse_dense_oper_consistent(
            tfim.z,
            **self.params,
        )
                
    def test_x_consistent (self):
        """Check consistency of methods in ph121c_lxvm.tfim.x."""
        self.check_sparse_dense_oper_consistent(
            tfim.x, 
            **self.params,
            **dict(sector=['+', '-', 'f']),
        )
        
    def test_z_x_interconsistent (self):
        """Check that the matrices produced by x and z are a change of basis."""
        for params in param_sweep(**self.params):
            with self.subTest(name='compare:z_elem==x_elem', **params):
                # get H_x in the full basis
                xf = tfim.x.H_dense(sector='f', **params)
                # direct sum of sectors to obtain H_x in full basis
                xp = tfim.x.H_dense(sector='+', **params)
                xm = tfim.x.H_dense(sector='-', **params)
                xd = np.zeros(np.add(xp.shape, xm.shape))
                xd[:xp.shape[0], :xp.shape[1]] = xp
                xd[xp.shape[0]:, xp.shape[1]:] = xm
                # permute direct sum to full basis
                iperm = basis.unitary.Ising(params['L'], inverse=True)
                self.assertTrue(
                    np.allclose(xf, xd[iperm, :][:, iperm])
                )
                # perform change from z basis to x basis
                zf = tfim.z.H_dense(**params)
                hd = basis.unitary.Hadamard(params['L'])
                self.assertTrue(
                    np.allclose(xf, hd @ zf @ hd)
                )
                # Test decomposition into sectors
                perm = basis.unitary.Ising(params['L'])
                self.assertTrue(
                    np.allclose((hd @ zf @ hd)[perm, :][:, perm], xd)
                )

        
if __name__ == '__main__':
    unittest.main()